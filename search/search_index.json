{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"Chispa and Lola: The Quest for the Golden Tennis Ball <p>This site is dedicated to hosting the devlog for the Quest for the Golden Tennis Ball. Follow along with me as I learn what it takes to make a game. I plan to cover everything in the development process from the art to the code. I'll even include some Unity specific scripts for the aspiring game dev.  </p> <p>So sit back, relax, and enjoy this journey to make the Quest for the Golden Tennis Ball.  </p> Welcome to The Quest for the Golden Tennis Ball."},{"location":"contact/","title":"Contact","text":"<p>Are you looking to contribute to the Golden Tennis Ball? Send me an email! goldentennisballofficial@gmail.com</p>"},{"location":"2025/11/18/firstPost/","title":"Getting Started","text":"Site Contents<ul> <li>Welcome<ul> <li>What is the Quest for the Golden Tennis Ball?</li> <li>Who are Chispa and Lola?</li> <li>History</li> </ul> </li> </ul>"},{"location":"2025/11/18/firstPost/#welcome","title":"Welcome","text":"<p>Welcome to the Quest for the Golden Tennis Ball devlog! This is the first of many posts detailing the development of The Quest for the Golden Tennis Ball (GTB). In this post, I'll talk about what the game is, introduce its stars, Chispa and Lola, and share a little history behind the project.</p>"},{"location":"2025/11/18/firstPost/#what-is-the-quest-for-the-golden-tennis-ball","title":"What is the Quest for the Golden Tennis Ball?","text":"<p>The Quest for the Golden Tennis Ball is a 2D platformer developed in Unity. The game follows Chispa, Lola, and their friends on a cross-country journey to find the Golden Tennis Ball. It draws inspiration from classics like Sonic the Hedgehog 2 as well as modern hits like Celeste and Pizza Tower.  </p> <p></p> <p>The story is born out of the homesickness I felt after moving across the country and showcases the special bond people share with their four-legged friends.</p>"},{"location":"2025/11/18/firstPost/#who-are-chispa-and-lola","title":"Who are Chispa and Lola?","text":"<p>Chispa and Lola are the stars of this game \u2014 they are my dogs, and each has their own unique personality.  </p> Chispa run animation test. <p>Chispa is smart, curious, and friendly. She will be the first to tell you that she has never met a stranger.  </p> Lola run animation test. <p>Lola is small, snuggly, and shy. While Chispa shines in the limelight, Lola prefers to hide from strangers under the bed. </p>"},{"location":"2025/11/18/firstPost/#history","title":"History","text":"<p>Making a game was one of those moments where I thought, \u201cHow hard could it be?\u201d \u2014 and then promptly found out. Despite years of coding experience, making a game has proven to be the most difficult project I've ever taken on.  </p> <p>In early 2024, I was dabbling in pixel art when I realized I didn\u2019t have a place to show it off. Sure, I could make another mod for Barotrauma, but the dark depths of Europa are no place for little Lola. I had been toying with the idea of making a game for about a year at that point. One morning, my wife and I came up with the story for the Golden Tennis Ball over breakfast and put together a rough draft of the levels. That draft sat on my desk for months. Reading it and looking at my animations of Lola, I decided it was finally time to make The Golden Tennis Ball.  </p> <p>Development began in Python using PyGame. I built my own spawning systems, controls, and even a small intro cutscene that I shared with friends. Progress was slow and frustrating. I had heard the term \u201cGame Engine\u201d but didn\u2019t really know what it meant. Eventually, with development driving me insane, I googled \u201cwhat is a game engine?\u201d \u2014 and immediately both Godot and Unity appeared. They changed everything.  </p> <p>I experimented with both engines, attempting to rebuild the level I had made in PyGame. Ultimately, I chose Unity. It was easier for me to learn, had tons of resources, and allowed me to expand my software skills \u2014 learning C# was an opportunity I couldn\u2019t pass up. From there, I began building the different systems that make up The Golden Tennis Ball.</p> <p>That\u2019s all for now! In the next post, I\u2019ll cover character controller design and the different approaches I\u2019ve taken to build a controller that feels good to use.</p>"},{"location":"2025/12/29/CharacterController/","title":"Character Controllers","text":"Site Contents<ul> <li>Character Controllers<ul> <li>What is a character controller?</li> </ul> </li> <li>Character Controller Basics<ul> <li>The Physics Loop</li> <li>Colliders</li> <li>Raycasts</li> </ul> </li> <li>The Golden Tennis Ball's Character Controller.<ul> <li>The Input/Output Model</li> <li>Converting Velocity to Position Change</li> <li>Talk about Unity's Translate method</li> <li>How by defining a velocity we're actually calculating a position change</li> <li>How this setup lends itself to being used in a physics manager</li> <li>Why scriptable objects are amazing</li> <li>Maybe next time I will talk about game feel and some of the math behind it.</li> </ul> </li> </ul>"},{"location":"2025/12/29/CharacterController/#character-controllers","title":"Character Controllers","text":"<p>After a month of waiting I finally found the time to sit down and write another post. This post is going to cover Character Controllers in the context of a 2D platformer. After covering the basic concepts I'll walk you through the different types of controllers I've tried as well as their pros and cons.</p>"},{"location":"2025/12/29/CharacterController/#what-is-a-character-controller","title":"What is a character controller?","text":"<p>Before I talk about the nuances of the different types of character controllers I'd like to cover the basics of what a character controller is and what it does in the context of a 2D platformer like the Golden Tennis Ball.</p> <p>A character controller, or simply a controller, refers to the code that reads button presses, clicks, joy stick input, etc, and translates those inputs into actions that the character performs.</p> Translating inputs into actions. <p>As you can see in the above gif, Chispa performs a different action based on the different controller inputs. In 2D platformers, character controllers are everything. A poorly designed controller means that the player will spend more time fighting the controller than actually playing the game.</p> <p>From a high level, character controllers are very simple. You pass an input and get an output, but there is more to it than that. How a character controller handles inputs dictates how the game feels.</p> <p>How a game feels is dependent on many different factors like input lag, movement speed, and  gravity just to name a few. Depending on what kind of game you're making dictates what sort of features your character controller needs to implement in order to feel good. With all of this in mind, lets talk through the evolution of the Golden Tenniball's character controller.</p> <pre><code>stateDiagram-v2\n    state fork_state&lt;&lt;fork&gt;&gt;\n    [*] --&gt; fork_state\n    fork_state --&gt; Grounded\n    Grounded --&gt; Idle\n    Idle --&gt; Jumping\n    Idle --&gt; Falling\n    Grounded --&gt; Running\n    Running --&gt; Jumping\n    Running --&gt; Falling\n    Grounded --&gt; Grabbing\n    Grabbing --&gt; Pulling\n    Grabbing --&gt; Jumping\n    Grabbing --&gt; Falling\n    Grounded --&gt; Down\n    Down --&gt; Crawl\n    Crawl --&gt; Down\n\n    fork_state --&gt; Airborne\n    Airborne --&gt; Jumping\n    Airborne --&gt; Falling\n    Airborne --&gt; Grabbing\n    Grabbing --&gt; Swinging\n    Swinging --&gt; Falling</code></pre> \\[ F = ma \\]"},{"location":"2025/12/29/CharacterController/#character-controller-basics","title":"Character Controller Basics","text":"<p>Before we can really get into the nitty gritty of how my controller works we need to talk about some basic computer physics things:</p> <ul> <li>Physics Loops</li> <li>Colliders</li> <li>Raycasts</li> </ul> <p>Once you understand these basics everything else will click into place.</p>"},{"location":"2025/12/29/CharacterController/#the-physics-loop","title":"The Physics Loop","text":"<p>Before we can talk about colliders and raycasts we need to talk about what a physics loop is. Most people know that games, like movies and tv shows, run a specified framerate, but unlike movies and tv shows, framerates for games can fluctuate. The framerate will change based on what is going on in the game. For example if there are a lot of objects on screen that can tank your framerate. </p> <p>Having an unsteady framerate is awful for physics calculations because the math behind the physics relies on a time consistent interval between calculations. This is where a physics loop comes in. A physics loop is where physics calculations are performed. The loop is called at a specific intervals and runs independently of the games framerate.</p> <p>Within the physics loop the game calculates forces on objects, resolves collisions, and moves objects at a consistent interval. If you were to perform your physics calculations outside of the physics loop weird things would happen, like tunneling.</p> <p>Tunneling is a phenomena where a solid object magically passes through another solid object like a wall or the floor. If you tied your movement and collision calculations to the framerate and it suddenly dropped, the player could tunnel through objects because in that moment they would be moving faster than the game could calculate collisions. To the moving player the physics calculations would say there was no object in their way, therefore, they can move forward. However, once the framerate stabilized again the player would be trapped inside the object they just passed through.</p> Player begins moving Framerate drops Collisions can't be resolved so the player begins tunneling. Physics catches back up and traps player. <p>To summarize this, a physics loop performs calculations at a consistent interval. Then those calculations are used to resolve collisions and move objects around. If those calculations are not performed at a consistent interval weird things happen.</p> <p>With the physics loop out of the way, lets talk about colliders!</p>"},{"location":"2025/12/29/CharacterController/#colliders","title":"Colliders","text":"<p>Colliders are part of the physical representation of objects within a game. They are invisible shapes placed on game objects that define their physical boundaries. Colliders can take many shapes. They can be as simple as a circle or as complex as the Great Rhombicosidodecahedron<sup>1</sup>. </p> A bead version of the Great Rhombicosidodecahedron.  <p>Granted if you made something that complicated your computer might have trouble calculating it's physical properties. This shape has 62 faces, 60 vertices, and 120 edges and with the physics loop firing every 50 ms your CPU might start to beg for mercy.</p> <p>Colliders allow for realistic simulations of objects within a game. They provide boundaries that describe an objects position in space and prevent objects from overlapping one another. Without colliders, all objects would simply pass through one another. Colliders can move, like the player's collider, or they can be stationary, like the floor. </p> <p>The most important job for a collider is collision detection. Collision detection is the act of checking what objects are touching one another. Collision detection can be expanded to determine what specific objects are touching, where relative to each other they are touching, and how hard the objects collided when they began touching. All of which is very important when you want build a physics based game!</p>"},{"location":"2025/12/29/CharacterController/#raycasts","title":"Raycasts","text":"<p>Raycasts are a type of physics query used to detect colliders along a path. Think of a raycast as a laser that detects objects it is pointed at. </p> <p>A raycast is a type of shape-cast. Shape-casts are physics queries that use shapes shot along a given path to detect objects. A raycast is called a raycast because the shape generated is a one pixel wide ray. The images below will hopefully clear up this concept.</p> Raycast - a single point projected along a path. Circle cast - a circle projected along a path. Square cast - a square projected along a path. <p>When a raycast (or any shape cast) collides with an object it returns information like the objects, distance from where the cast began, the speed of the object, and more! </p> <p>Now that we've covered the basics of character controllers and game physics; we can finally talk about the character controller for the Golden Tennis Ball.</p>"},{"location":"2025/12/29/CharacterController/#the-golden-tennis-balls-character-controller","title":"The Golden Tennis Ball's Character Controller.","text":"<p>Now we can talk about the Golden Tennis Ball's character controller. The controller has been redesigned from the ground up four different times before finally settling on the current configuration. The way the controller works is simple.  1. The player gives an input to the controller.  2. The controller converts that input into a speed and direction.  3. The controller checks for obstacles. 4. Then the player is moved.</p>"},{"location":"2025/12/29/CharacterController/#the-inputoutput-model","title":"The Input/Output Model","text":"<p>There are three scripts that control movement for the character. The <code>InputHandler</code>, <code>PhysicsHandler</code>, and the <code>RaycastController</code>. The <code>InputHandler</code> reads player inputs and calculates then player's requested velocity. The <code>PhysicsHandler</code> takes the requested velocity, converts it into a distance. The <code>RaycastController</code> determines if the player can move.</p> <p>The flow of data through the controller always flows from the <code>InputHandler</code> to the <code>PhysicsHandler</code> resulting in a simple input/output relationship.</p> <p></p><pre><code>graph LR\n  A[Player Presses Button] --&gt; B[InputHandler calculates \n  the new velocity];\n  B --&gt;C[PhysicsHandler converts \n  velocity to distance];\n  C --&gt;D[RaycastController \n  checks collisions \n  and moves the player]\n</code></pre> Getting the inputs from the player is the easy part. I used Unity's new event system to broadcast events whenever the player presses a button or moves the joystick. Converting those inputs from a velocity to a distance is the strange part.<p></p>"},{"location":"2025/12/29/CharacterController/#converting-velocity-to-position-change","title":"Converting Velocity to Position Change","text":"<p>You might be wondering, \u201cwhy are we converting a velocity to a position?\u201d and that is a valid question. </p> <p>We convert velocity to position change because of the method we use to move our player, <code>Translate()</code>. The <code>Translate()</code> method takes a change in position and moves an object that distance. <code>Translate()</code> is called in the physics loop of the game so that in each physics step the player moves a set distance based off of the player's velocity.</p> <p>So how do we convert the velocity to a change in position? By multiplying it by the physics loops step interval. Remember from physics that velocity is the change in position divided by the time. $$ V = \\frac{dx}{dt} $$ Therefore, we to get the change in position we can modify the equation to be: $$ dx = Vt $$ Where: - V is the current velocity - t is the time between physics steps</p> <p>We can even extend this further to handle accelerations: $$ a = \\frac{\u03b4x}{dt^2} $$ Which becomes: $$ dx = at^2 $$</p> <p>In practice </p> <p>We convert the velocity to position because the game\u2019s physics loop runs in discrete steps, and in each step or tick, all of the objects\u2014including the player\u2014have one well-defined position. Think of it like watching an animation frame by frame: where each frame is one physics step. During a physics step, the game engine treats objects as being at fixed positions while it performs the calculations needed to advance the simulation, determining their new positions and velocities by the end of that step.</p>"},{"location":"2025/12/29/CharacterController/#talk-about-unitys-translate-method","title":"Talk about Unity's <code>Translate</code> method","text":""},{"location":"2025/12/29/CharacterController/#how-by-defining-a-velocity-were-actually-calculating-a-position-change","title":"How by defining a velocity we're actually calculating a position change","text":""},{"location":"2025/12/29/CharacterController/#how-this-setup-lends-itself-to-being-used-in-a-physics-manager","title":"How this setup lends itself to being used in a physics manager","text":""},{"location":"2025/12/29/CharacterController/#why-scriptable-objects-are-amazing","title":"Why scriptable objects are amazing","text":""},{"location":"2025/12/29/CharacterController/#maybe-next-time-i-will-talk-about-game-feel-and-some-of-the-math-behind-it","title":"Maybe next time I will talk about game feel and some of the math behind it.","text":"<ol> <li> <p>According to google, and apparently math, this is the most complicated shape there is. Here's a link!\u00a0\u21a9</p> </li> </ol>"},{"location":"2025/Game%20Feel/colliderShapes/","title":"colliderShapes","text":"<p>date: 2025-12-32 title: Game Feel description: A post about getting the perfect feel for your game</p> <p>[TOC] By now you might be wondering, if having complicated physical shapes is expensive in terms of computing power, how do games do it? The answer: they don't! Usually colliders only approximate the shape of object the player sees. This is done for two reasons:</p> <ol> <li>It's easier on the computer and generally accurate enough.</li> <li>It helps the player.</li> </ol> Chispa's collider.  <p>The above image is Chispa's actual collider. Notice how it only covers her body; Chispa's head and tail don't collide with anything. This means that if a rogue tennis ball collides with Chispa's head or tail it won't do anything! This is what I mean when I saw that approximating the shape of the character helps the player. Having a smaller collider helps the player move around the world without getting caught on things and makes it harder for enemies to hurt them. In fact developers usually undersize colliders for things that can hurt the player. This makes the game feel more fair. Instead of taking damage when a hazard barely touches you, the hazard needs to have a direct hit to hurt the player.</p> A spike collider. Note that the player can actually touch the tips of the spikes without taking damage."},{"location":"2026/01/03/Pupdate/","title":"Pupdate 2026-01-03","text":""},{"location":"2026/01/03/Pupdate/#2026-01-03","title":"2026-01-03","text":"<p>Hi there, long time no see! This devlog is devoted to the journey of building my first game, The Quest for the Golden Tennis Ball. Now I know that I said the next post would be about character controllers, but that post proved to be quite the challenge. My goal is to make these posts fun and accessible. You shouldn't need a degree in engineering to read about your favorite pups! </p> <p>As a result, the character controller post needs a rewrite and will likely be broken up into multiple different posts. The nuance of designing a good character controller is very technical.</p>"},{"location":"2026/01/03/Pupdate/#whats-new","title":"What's New?","text":"<p>So besides not posting sooner, what have the girls and I been up to? Well right before Thanksgiving, we released the latest build of the game, version 0.2.1.0. Some of the highlights of this version include:</p> <ul> <li>A brand new level</li> <li>A revamped character controller</li> <li>Hazards</li> <li>New music</li> <li>Improved camera work</li> </ul> <p>Now before you get too excited, there is a dark side to this update...</p> Lola meets confronts her dark side."},{"location":"2026/01/03/Pupdate/#the-dark-side","title":"The Dark Side","text":"<p>Despite having been working on this project now for over a year, I have been so busy adding and removing features, tweaking things, drawing, and composing that I have neglected testing. Sure, I've played the game, a lot, but when I play the game it is more to test out the feel and ensure features are working. It isn't that structured. While I'm able to check things like button presses and door triggers easily, I'm not always looking for the more subtle problems.</p> <p>As a result, this latest build is FULL of bugs, which is why I haven't told many people about it. Some of the bugs include:</p> <ul> <li>Only dying to spikes once.</li> <li>Going out of bounds has no effect.</li> <li>The game soft locks if you quit to the main menu.</li> <li>Music randomly loops.</li> <li>Points and dinosaurs don't update in the HUD.</li> <li>The timer is visible and doesn't do anything.</li> <li>Starting the music causes a huge lag spike.</li> <li>One of the platforms Rocks You Like A Hurricane!</li> </ul> <p>And these are just the bugs that I know about.</p> Ian confused about how things could get worse. <p>If you've never written code before you might be thinking \"wow, the girls should hire a new dev,\" but issues like this are actually expected. Granted this many bugs shouldn't reach the player, but this is a one man and two dog show! The girls can only audit so much code.</p> Chispa reviewing my latest pull request."},{"location":"2026/01/03/Pupdate/#the-fix","title":"The Fix","text":"<p>Ever since these bugs came to light, I've been working out how to fix them, and more importantly prevent them from happening again. The answer? Testing. Testing in software development means writing code to exercise different parts of your code and verify that it works. Tests are great because they're automated and repeatable. I can spend the day working on the game and then run my tests overnight to figure out what's broken. Right now I am focused on three types of testing: unit testing, integration testing, and regression testing.</p>"},{"location":"2026/01/03/Pupdate/#unit-testing","title":"Unit Testing","text":"<p>Unit testing is the act of exercising small parts of your code to verify that each unit works as intended. In unit testing you are concerned with how each method works on its own not how the methods work together as a whole. For example say you had two functions that work together to make the player jump. </p><pre><code>public void GetJumpButtonPress()\n\npublic void AddJumpForce()\n</code></pre><p></p> <p><code>GetJumpButtonPress()</code> detects if the jump button was pressed and <code>AddJumpForce()</code> applies a force to move the player vertically. Together, these methods produce a jump, but individually they perform specialized actions. Unit testing would test that <code>GetJumpButtonPress()</code> accurately receives jump button presses and that <code>AddJumpForce()</code> applies a vertical force to the player. Notice that neither one of these tests actually check if the player jumped. Their only concern is how each individual method works. Testing how methods work together is reserved for integration testing.</p>"},{"location":"2026/01/03/Pupdate/#integration-testing","title":"Integration Testing","text":"<p>Integration testing tests how different units of code work together. In a sense it tests the connections between different methods and verifies that the end result is what we expect. In the above example we saw how unit tests verify that individual parts of our code work independently. An integration test would verify that the different parts of our code work together. Using the above jump example, integration testing would be used to verify that <code>GetJumpButtonPress()</code> and <code>AddJumpForce()</code> work together to produce a jump.</p>"},{"location":"2026/01/03/Pupdate/#regression-testing","title":"Regression Testing","text":"<p>The joke in software engineering is that the best way to break your code is to fix it. What do I mean by that? Well no matter how much you try and decouple<sup>1</sup> a program there is still going to be some level of coupling. Everything has to rely on something. So if you fix a bug in one part of your code, there is a non-zero chance that you wind up breaking a different part of your code with that \"fix.\" This is where regression testing comes in.</p> <p>Regression testing is the act of rerunning tests after you change something. The goal is to keep your program from moving backwards, from regressing. Regression testing is usually a part of a CI/CD pipeline<sup>2</sup>. When your code is ready for release, the CI/CD pipeline will run the tests you have previously written to verify that your new features don't break your old ones.</p>"},{"location":"2026/01/03/Pupdate/#so-whats-going-on","title":"So What's Going On?","text":"<p>Right now the game has a lot of personality, too much personality for my taste. So I'm reorganizing my code into more manageable pieces and setting up an actual build-test workflow for the game. This reorganization needs to happen and I have been putting it off for a long time now. Once my CI/CD pipeline is running tests and not just building the game, I'll be able to release the fixes for the current version. </p> <p>In the meantime, be on the look out for lore posts! I plan to write up a profile for each of the characters in the game to help build out the world.</p> <p>As for now, thanks for reading! You're welcome to play the current build of the game if you want, just know it might be frustrating. If you don't have access to the latest build and would like to join my freelance play test group send me an email!</p> <ol> <li> <p>Decoupling in software development is the act of reducing how much one object depends on another.\u00a0\u21a9</p> </li> <li> <p>A CI/CD pipeline or a continuous integration/continuous deployment pipeline is a workflow for building and releasing software. A CI/CD pipeline is used for testing, building, and deploying software in a repeatable way.\u00a0\u21a9</p> </li> </ol>"}]}